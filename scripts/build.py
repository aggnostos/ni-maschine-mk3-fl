"""Build script to generate a single-file MIDI script"""

import ast
import black
import logging
from pathlib import Path
from typing import List, Optional, Set, Tuple, Dict


logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG, format="[%(levelname)s] %(message)s")


SRC = Path("src")
DIST = Path("dist")
DIST.mkdir(exist_ok=True)

MAIN_PATH: Path = SRC / "main.py"

OUT_FILE = "device_Maschine_MK3.py"

OUT_PATH: Path = DIST / OUT_FILE

# List of local packages (folders with __init__.py) to include
PACKAGES: List[str] = []

# List of local modules (single .py files) to include
MODULES: List[str] = [
    "consts",
    "enums",
    "notes",
    "controls",
    "utilities",
    "controller",
]

MIDI_SCRIPT_NAME: str = "NI Maschine MK3"

HEADER: str = """
# ------------------------------------------------------------------------- #
#  THIS FILE IS AUTO-GENERATED                                              #
#  DO NOT EDIT THIS FILE MANUALLY.                                          #
#                                                                           #
#  Any changes made to this file will be overwritten.                       #
# ------------------------------------------------------------------------- #
"""


class CommonVisitor(ast.NodeVisitor):
    def __init__(self) -> None:
        self.imports: ast.Module = ast.Module(body=[], type_ignores=[])
        self.body = ast.Module(body=[], type_ignores=[])
        self.constants: Dict[str, ast.AST] = {}
        self.enums: Dict[str, Dict[str, ast.AST]] = {}
        self.curr_enum: str | None = None
        self.is_in_class = False

    def visit_Module(self, node: ast.Module) -> None:
        self.generic_visit(node)
        for stmt in node.body:
            if not isinstance(stmt, (ast.Import, ast.ImportFrom)):
                self.body.body.append(stmt)

    def visit_ClassDef(self, node: ast.ClassDef) -> None:
        old_in_class = self.is_in_class
        self.is_in_class = True

        is_in_enum = any(
            base
            for base in node.bases
            if isinstance(base, ast.Name) and base.id in ("Enum", "IntEnum")
        )

        if is_in_enum:
            self.curr_enum = node.name
            self.enums[self.curr_enum] = {}
        else:
            self.curr_enum = None

        self.generic_visit(node)

        self.is_in_class = old_in_class

    def visit_Assign(self, node: ast.Assign) -> None:
        target = node.targets[0]
        if isinstance(target, ast.Name) and target.id.isupper():
            if not self.is_in_class:
                self.constants[target.id] = node.value
            elif self.curr_enum is not None:
                self.enums[self.curr_enum][target.id] = node.value

    def visit_Import(self, node: ast.Import) -> None:
        self.imports.body.append(node)

    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        self.imports.body.append(node)


class ImportsRemover(ast.NodeTransformer):
    def __init__(self) -> None:
        self._seen: Set[Tuple[str, ...]] = set()
        self.result: ast.Module = ast.Module(body=[], type_ignores=[])

    def visit_Import(self, node: ast.Import) -> Optional[ast.Import]:
        if self._is_local(node) or self._is_duplicate(node):
            return None
        return node

    def visit_ImportFrom(self, node: ast.ImportFrom) -> Optional[ast.ImportFrom]:
        if (
            self._is_local(node)
            or self._is_duplicate(node)
            or self._is_fl_classes(node)
        ):
            return None

        return node

    def _is_local(self, node: ast.AST) -> bool:
        if isinstance(node, ast.ImportFrom):
            return node.module in MODULES or node.module in PACKAGES
        if isinstance(node, ast.Import):
            return any(
                alias.name in MODULES or alias.name in PACKAGES for alias in node.names
            )
        return False

    def _is_duplicate(self, node: ast.AST) -> bool:
        key = self._get_import_key(node)
        if key in self._seen:
            return True
        self._seen.add(key)
        return False

    def _is_fl_classes(self, node: ast.AST) -> bool:
        return isinstance(node, ast.ImportFrom) and node.module == "fl_classes"

    def _get_import_key(self, node: ast.AST) -> Tuple[str, ...]:
        if isinstance(node, ast.Import):
            return ("import", *tuple(sorted(alias.name for alias in node.names)))
        if isinstance(node, ast.ImportFrom):
            return (
                "from",
                node.module or "",
                *tuple(sorted(alias.name for alias in node.names)),
            )
        return ()


class AllRemover(ast.NodeTransformer):
    def visit_Assign(self, node: ast.Assign) -> Optional[ast.Assign]:
        # Remove __all__ assignments
        if any(
            isinstance(target, ast.Name) and target.id == "__all__"
            for target in node.targets
        ):
            return None
        return node


class FlMidiMsgRemover(ast.NodeTransformer):
    def visit_arg(self, node: ast.arg) -> ast.arg:
        # Remove FlMidiMsg type annotations from function arguments
        if (
            node.annotation
            and isinstance(node.annotation, ast.Name)
            and node.annotation.id == "FlMidiMsg"
        ):
            node.annotation = None
        return node


class DocstringRemover(ast.NodeTransformer):
    """AST transformer to clean up the code body"""

    def visit_Module(self, node: ast.Module) -> ast.Module:
        self.generic_visit(node)
        return self._remove_docstring(node)  # type: ignore[return-value]

    def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:
        self.generic_visit(node)
        return self._remove_docstring(node)  # type: ignore[return-value]

    def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:
        self.generic_visit(node)
        return self._remove_docstring(node)  # type: ignore[return-value]

    def _remove_docstring(self, node: ast.AST) -> ast.AST:
        body = getattr(node, "body", None)
        if not body:
            return node

        first = body[0]
        if (
            isinstance(first, ast.Expr)
            and isinstance(first.value, ast.Constant)
            and isinstance(first.value.value, str)
        ):
            body.pop(0)

        return node


class ConstReplacer(ast.NodeTransformer):
    def __init__(self, constants: Dict[str, ast.AST]):
        self.constants = constants

    def visit_Name(self, node: ast.Name):
        if isinstance(node.ctx, ast.Load) and node.id in self.constants:
            return self.visit(self.constants[node.id])
        return node


class ConstRemover(ast.NodeTransformer):
    def __init__(self, constants: Dict[str, ast.AST]):
        self.const_names = set(constants.keys())

    def visit_Assign(self, node: ast.Assign):
        target = node.targets[0]
        if isinstance(target, ast.Name) and target.id in self.const_names:
            return None
        return node


class EnumReplacer(ast.NodeTransformer):
    def __init__(self, enums: Dict[str, Dict[str, ast.AST]]):
        self.enums = enums

    def visit_Attribute(self, node: ast.Attribute):
        if isinstance(node.value, ast.Name):
            enum_name = node.value.id
            member_name = node.attr
            if enum_name in self.enums and member_name in self.enums[enum_name]:
                return self.visit(self.enums[enum_name][member_name])
        return node


def main() -> None:
    logger.info("Building MIDI script...")

    common_visitor = CommonVisitor()

    def _process_module(mod_path: Path) -> None:
        source: str = mod_path.read_text(encoding="utf-8")
        tree = ast.parse(source, mod_path.name)
        common_visitor.visit(tree)

    for pkg in PACKAGES:
        pkg_path: Path = SRC / pkg
        if not Path.exists(pkg_path):
            logger.warning(f"Package {pkg} not found, skipping.")
            continue
        pkg_files: List[Path] = list(pkg_path.glob("*.py"))
        for mod_path in sorted(pkg_files):
            _process_module(mod_path)

    for mod in MODULES:
        mod_path: Path = SRC / f"{mod}.py"
        if not Path.exists(mod_path):
            logger.warning(f"Module {mod}.py not found, skipping.")
            continue
        _process_module(mod_path)

    _process_module(MAIN_PATH)

    with open(OUT_PATH, "w", encoding="utf-8") as out:
        out.write(f"# name={MIDI_SCRIPT_NAME}\n\n")
        out.write(HEADER + "\n\n")

        imports = ImportsRemover().visit(common_visitor.imports)
        ast.fix_missing_locations(imports)
        out.write(ast.unparse(imports) + "\n\n\n")

        body = common_visitor.body
        constants = common_visitor.constants
        enums = common_visitor.enums

        body = AllRemover().visit(body)
        body = FlMidiMsgRemover().visit(body)
        body = DocstringRemover().visit(body)
        body = ConstReplacer(constants).visit(body)
        body = ConstRemover(constants).visit(body)
        body = EnumReplacer(enums).visit(body)
        ast.fix_missing_locations(body)
        out.write(ast.unparse(body))

    black.format_file_in_place(
        OUT_PATH,
        fast=True,
        mode=black.FileMode(),
        write_back=black.WriteBack.YES,
    )

    logger.info(f"Done. Built MIDI script at {OUT_PATH.resolve()}")


if __name__ == "__main__":
    main()
