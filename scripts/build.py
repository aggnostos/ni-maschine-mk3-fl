"""Build script to generate a single-file MIDI script"""

import re
import logging
from os import path
from io import StringIO
from pathlib import Path
from typing import List, Set, Tuple


logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG, format="[%(levelname)s] %(message)s")


SRC = Path("src")
DIST = Path("dist")
DIST.mkdir(exist_ok=True)

MAIN_PATH: Path = SRC / "main.py"

OUT_FILE = "device_Maschine_MK3.py"

# OUT_PATH: Path = DIST / OUT_FILE

OUT_PATH = (
    Path(
        "/Users/aggnostos/Documents/Image-Line/FL Studio/Settings/Hardware/NI Machine MK3"
    )
    / OUT_FILE
)

# List of local packages (folders with __init__.py) to include
PACKAGES: List[str] = []

# List of local modules (single .py files) to include
MODULES: List[str] = [
    "consts",
    "enums",
    "notes",
    "controls",
    "utilities",
    "controller",
]

MIDI_SCRIPT_NAME: str = "NI Maschine MK3"

HEADER: str = """
# ------------------------------------------------------------------------- #
#  THIS FILE IS AUTO-GENERATED                                              #
#  DO NOT EDIT THIS FILE MANUALLY.                                          #
#                                                                           #
#  Any changes made to this file will be overwritten.                       #
# ------------------------------------------------------------------------- #
"""

# Regular expression for matching import statements
IMPORT_RE = re.compile(
    r"^(import|from)\s+[a-zA-Z_][\w.]*\b.*$",
    re.MULTILINE,
)

# Regular expression for matching __all__ exports
ALL_RE = re.compile(
    r"^__all__\s*=\s*\[[^\]]*\]\s*\n?",
    re.MULTILINE | re.DOTALL,
)


def _split_imports_and_body(source: str) -> Tuple[List[str], str]:
    """Splits the source code into imports and body."""

    matches = list(IMPORT_RE.finditer(source))
    if not matches:
        return [], source

    imports = [m.group() for m in matches]
    body_start = matches[-1].end()

    return imports, source[body_start:]


def _remove_local_imports(imports: Set[str]) -> Set[str]:
    """Removes imports that are from local packages/modules."""

    result: Set[str] = set()
    for imp in imports:
        if not any(
            imp.startswith(f"import {pkg}") or imp.startswith(f"from {pkg}")
            for pkg in PACKAGES + MODULES
        ):
            result.add(imp)
    return result


def _prepare_imports(imports: Set[str]) -> List[str]:
    """Prepares and sorts the imports for the final output."""
    result = _remove_local_imports(imports)
    result.remove("from fl_classes import FlMidiMsg")
    return sorted(list(result), key=len)


def _remove_all_exports(source: str) -> str:
    """Removes __all__ exports from the source code."""
    return ALL_RE.sub("", source)


def _remove_FlMidiMsg_annotations(
    source: str,
) -> str:
    """Removes FlMidiMsg type annotations from the source code as they will raise errors running in FL Studio environment."""
    return re.sub(r":\s*FlMidiMsg\b", "", source)


def _process_module(path: Path, imports: Set[str], body: StringIO) -> None:
    """Processes a module file, extracting imports and body."""
    with open(path, encoding="utf-8") as pkg_file:
        pkg_imports, pkg_body = _split_imports_and_body(pkg_file.read())
        imports.update(pkg_imports)
        body.write(pkg_body)


def main():
    logger.info("Building MIDI script...")

    all_imports: Set[str] = set()
    pkg_body_buf = StringIO()
    main_body_buf = StringIO()

    # ---- main.py ----
    with open(MAIN_PATH, encoding="utf-8") as main:
        imports, main_body = _split_imports_and_body(main.read())
        all_imports.update(imports)
        main_body_buf.write(main_body)

    # ---- packages ----
    for pkg in PACKAGES:
        pkg_path = SRC / pkg
        if not path.exists(pkg_path):
            logger.warning(f"Package {pkg} not found, skipping.")
            continue

        pkg_files = list(pkg_path.glob("*.py"))
        for pkg_file in sorted(pkg_files):
            if pkg_file.name == "__init__.py":
                continue
            _process_module(pkg_file, all_imports, pkg_body_buf)

    # ---- modules ----
    for mod in MODULES:
        mod_path = SRC / f"{mod}.py"
        if not path.exists(mod_path):
            logger.warning(f"Module {mod}.py not found, skipping.")
            continue
        _process_module(mod_path, all_imports, pkg_body_buf)

    # ---- write output ----
    with open(OUT_PATH, "w", encoding="utf-8") as out:
        out.write(f"# name={MIDI_SCRIPT_NAME}" + "\n\n\n")
        out.write(HEADER.strip() + "\n\n\n")

        out.write("\n".join(_prepare_imports(all_imports)) + "\n\n\n")

        combined_body = pkg_body_buf.getvalue() + main_body_buf.getvalue()
        combined_body = _remove_all_exports(combined_body)
        combined_body = _remove_FlMidiMsg_annotations(combined_body)

        out.write(combined_body)

    main_body_buf.close()
    pkg_body_buf.close()

    logger.info(f"Done. Built MIDI script at {OUT_PATH.resolve()}")


if __name__ == "__main__":
    main()
