# name=NI Maschine MK3


# ------------------------------------------------------------------------- #
#  THIS FILE IS AUTO-GENERATED                                              #
#  DO NOT EDIT THIS FILE MANUALLY.                                          #
#                                                                           #
#  Any changes made to this file will be overwritten.                       #
# ------------------------------------------------------------------------- #


import ui
import midi
import mixer
import device
import plugins
import general
import channels
import patterns
import transport
from enum import IntEnum


"""Constants"""

CC_RANGE = 128

NOTES_RANGE = 16

MIN_OCTAVE = -5
MAX_OCTAVE = 5

SEMITONES_IN_OCTAVE = 12

MIN_SEMI_OFFSET = SEMITONES_IN_OCTAVE * MIN_OCTAVE
MAX_SEMI_OFFSET = SEMITONES_IN_OCTAVE * MAX_OCTAVE

CHANNEL_VOL_STEP = 0.03125

MIXER_TRACK_VOL_STEP = 0.012125


class ControllerColor(IntEnum):
    """Maschine MK3 LED Colors"""

    BLACK_0 = 0
    BLACK_1 = 1
    BLACK_2 = 2
    BLACK_3 = 3
    RED_0 = 4
    RED_1 = 5
    RED_2 = 6
    RED_3 = 7
    ORANGE_0 = 8
    ORANGE_1 = 9
    ORANGE_2 = 10
    ORANGE_3 = 11
    LIGHT_ORANGE_0 = 12
    LIGHT_ORANGE_1 = 13
    LIGHT_ORANGE_2 = 14
    LIGHT_ORANGE_3 = 15
    WARM_YELLOW_0 = 16
    WARM_YELLOW_1 = 17
    WARM_YELLOW_2 = 18
    WARM_YELLOW_3 = 19
    YELLOW_0 = 20
    YELLOW_1 = 21
    YELLOW_2 = 22
    YELLOW_3 = 23
    LIME_0 = 24
    LIME_1 = 25
    LIME_2 = 26
    LIME_3 = 27
    GREEN_0 = 28
    GREEN_1 = 29
    GREEN_2 = 30
    GREEN_3 = 31
    MINT_0 = 32
    MINT_1 = 33
    MINT_2 = 34
    MINT_3 = 35
    CYAN_0 = 36
    CYAN_1 = 37
    CYAN_2 = 38
    CYAN_3 = 39
    TURQUOISE_0 = 40
    TURQUOISE_1 = 41
    TURQUOISE_2 = 42
    TURQUOISE_3 = 43
    BLUE_0 = 44
    BLUE_1 = 45
    BLUE_2 = 46
    BLUE_3 = 47
    PLUM_0 = 48
    PLUM_1 = 49
    PLUM_2 = 50
    PLUM_3 = 51
    VIOLET_0 = 52
    VIOLET_1 = 53
    VIOLET_2 = 54
    VIOLET_3 = 55
    PURPLE_0 = 56
    PURPLE_1 = 57
    PURPLE_2 = 58
    PURPLE_3 = 59
    MAGENTA_0 = 60
    MAGENTA_1 = 61
    MAGENTA_2 = 62
    MAGENTA_3 = 63
    FUCHSIA_0 = 64
    FUCHSIA_1 = 65
    FUCHSIA_2 = 66
    FUCHSIA_3 = 67
    WHITE_0 = 68
    WHITE_1 = 69
    WHITE_2 = 70
    WHITE_3 = 71


# -------- Plugin and channel colors for OMNI/PAD modes, feel free to change these with any others from the list --------
class PluginColor(IntEnum):
    """Plugin Colors"""

    DEFAULT = ControllerColor.ORANGE_1
    HIGHLIGHTED = ControllerColor.ORANGE_2


class ChannelColor(IntEnum):
    """Channel Colors"""

    DEFAULT = ControllerColor.WHITE_1
    HIGHLIGHTED = ControllerColor.WHITE_2


# ------------------------------------------------------------------------------------------------------------------------


class PadMode(IntEnum):
    """Pad Modes"""

    OMNI = 0
    KEYBOARD = 1
    CHORDS = 2
    STEP = 3


class PadModeColor(IntEnum):
    """Pad Mode Colors"""

    OMNI = ControllerColor.ORANGE_2
    KEYBOARD = ControllerColor.BLUE_2
    CHORDS = ControllerColor.RED_2
    STEP = ControllerColor.PURPLE_2


class FourDEncoderMode(IntEnum):
    """4D Encoder Modes"""

    JOG = 0
    VOLUME = 1
    SWING = 2
    TEMPO = 3


class TouchStripMode(IntEnum):
    """Touch Strip Modes"""

    TRANSPORT = 0
    PITCH = 1
    MOD = 2
    PERFORM = 3
    NOTES = 4


class PadGroup(IntEnum):
    """Pad Groups"""

    A = 100
    B = 101
    C = 102
    D = 103
    E = 104
    F = 105
    G = 106
    H = 107
"""Notes"""

# --------------------------------------------------------------------------------
# NOTES
# --------------------------------------------------------------------------------
# DO NOT CHANGE THE NOTE VALUES BELOW, UNLESS YOU KNOW WHAT YOU ARE DOING!

C1 = 0
CS1 = 1
D1 = 2
DS1 = 3
E1 = 4
F1 = 5
FS1 = 6
G1 = 7
GS1 = 8
A1 = 9
AS1 = 10
B1 = 11
C2 = 12
CS2 = 13
D2 = 14
DS2 = 15
E2 = 16
F2 = 17
FS2 = 18
G2 = 19
GS2 = 20
A2 = 21
AS2 = 22
B2 = 23
C3 = 24
CS3 = 25
D3 = 26
DS3 = 27
E3 = 28
F3 = 29
FS3 = 30
G3 = 31
GS3 = 32
A3 = 33
AS3 = 34
B3 = 35
C4 = 36
CS4 = 37
D4 = 38
DS4 = 39
E4 = 40
F4 = 41
FS4 = 42
G4 = 43
GS4 = 44
A4 = 45
AS4 = 46
B4 = 47
C5 = 48
CS5 = 49
D5 = 50
DS5 = 51
E5 = 52
F5 = 53
FS5 = 54
G5 = 55
GS5 = 56
A5 = 57
AS5 = 58
B5 = 59
C6 = 60
CS6 = 61
D6 = 62
DS6 = 63
E6 = 64
F6 = 65
FS6 = 66
G6 = 67
GS6 = 68
A6 = 69
AS6 = 70
B6 = 71
C7 = 72
CS7 = 73
D7 = 74
DS7 = 75
E7 = 76
F7 = 77
FS7 = 78
G7 = 79
GS7 = 80
A7 = 81
AS7 = 82
B7 = 83
C8 = 84
CS8 = 85
D8 = 86
DS8 = 87
E8 = 88
F8 = 89
FS8 = 90
G8 = 91
GS8 = 92
A8 = 93
AS8 = 94
B8 = 95
C9 = 96
CS9 = 97
D9 = 98
DS9 = 99
E9 = 100
F9 = 101
FS9 = 102
G9 = 103
GS9 = 104
A9 = 105
AS9 = 106
B9 = 107
C10 = 108
CS10 = 109
D10 = 110
DS10 = 111
E10 = 112
F10 = 113
FS10 = 114
G10 = 115
GS10 = 116
A10 = 117
AS10 = 118
B10 = 119
C11 = 120
CS11 = 121
D11 = 122
DS11 = 123
E11 = 124
F11 = 125
FS11 = 126
G11 = 127

ROOT_NOTE = C5

# --------------------------------------------------------------------------------
# CHORD SETS
# --------------------------------------------------------------------------------
# CHANGE THE NOTES INSIDE THE BRACKETS AS YOU PLEASE,YOU CAN EVEN ADD MORE THAN 4 NOTES FOR 7TH AND 9TH CHORDS!
# OR YOU CAN CREATE YOUR OWN CHORD SETS,
# JUST MAKE SURE THERE IS ALWAYS 16 CHORDS IN EACH CHORDSET!

min1 = [  # MINOR 1
    [C4, C5, DS5, G5],  # 1
    [DS4, C5, DS5, G5],
    [F4, C4, F5, GS5],
    [G3, B4, D5, G5],
    [GS3, C5, DS5, G5],  # 5
    [DS4, AS4, DS5, G5],
    [G3, AS4, D5, G5],
    [AS3, AS4, D5, F5],
    [F3, A4, C5, F5],  # 9
    [GS3, C5, F5, GS5],
    [G3, C5, DS5, G5],
    [G3, B4, D5, G5],
    [F3, D4, F5, GS5],  # 13
    [D4, D5, F5, AS5],
    [D4, C5, D5, G5],
    [C4, C5, F5, G5],
]

min2 = [  # MINOR 2
    [C4, G4, C5, DS5],
    [B3, G4, B4, DS5],
    [AS3, G4, C5, DS5],
    [G3, B4, D5, G5],
    [GS3, C5, DS5, G5],
    [DS4, AS4, DS5, G5],
    [G3, AS4, D5, G5],
    [AS3, AS4, D5, F5],
    [F3, A4, C5, F5],
    [GS3, C5, F5, GS5],
    [G3, C5, DS5, G5],
    [G3, B4, D5, G5],
    [C4, C5, DS5, G5],
    [F3, D4, F5, GS5],
    [AS3, D4, F5, AS5],
    [AS3, D4, D5, G5],
]

min3 = [  # SYNTHWAVE
    [C4, G4, C5, D5, G5],
    [C4, G4, AS4, D5, F5],
    [D4, A4, C5, D5, F5],
    [D4, A5, C5, E5, G5],
    [E4, G4, C5, D5, G5],
    [D4, G4, AS4, D5, F5],
    [A3, A4, C5, D5, F5],
    [A3, A4, C5, E5, G5],
    [DS4, DS5, FS5, AS5],
    [DS4, CS5, F5, GS5],
    [CS4, CS5, F5, GS5],
    [DS4, F5, GS5, CS6],
    [CS4, F5, GS5, CS6],
    [C4, DS5, GS5, C6],
    [C4, DS5, G5, AS5],
    [AS3, D4, G5, AS5],
]

min4 = [  # EPIC
    [CS3, D4, G4, AS4],
    [F3, C4, F4, A4],
    [G3, D4, G4, AS4],
    [AS3, F4, AS4, D5],
    [D3, A3, D4, F4],
    [C3, G3, C4, DS4],
    [F3, C4, F4, A4],
    [G3, D4, G4, AS4],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
    [C4, C5, DS5, G5],
]

maj1 = [
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
]

maj2 = [
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
]

maj3 = [
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
]

maj4 = [
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
    [C4, C5, E5, G5],
]

# THERE MUST BE EXACTLY 8 CHORD SETS!
CHORD_SETS = [min1, min2, min3, min4, maj1, maj2, maj3, maj4]

# --------------------------------------------------------------------------------
# SCALES
# --------------------------------------------------------------------------------
# CHANGE THE NOTES INSIDE THE BRACKETS AS YOU PLEASE OR ADD YOU OWN,
# JUST MAKE SURE THAT THERE IS EXACTLY 16 NOTES IN EACH GROUP!

# fmt: off
scale_1 = [C4, D4, GS4, AS4, CS4, E4, A4, F4, B4, FS4, DS4, G4, C5, CS5, D5, G5]  # BATTERY
scale_2 = [C5, D5, DS5, F5, G5, GS5, AS5, C6, D6, DS6, F6, G6, GS6, AS6, C7, D7]  # MINOR
scale_3 = [C5, D5, E5, F5, G5, A5, B5, C6, D6, E6, F6, G6, A6, B6, C7, D7]        # MAJOR
scale_4 = [CS4, C4, FS4, AS7, E4, D4, AS4, GS4, C5, B4, A4, G4, CS5, G5, DS5, F5] # FPC
scale_5 = [C5, CS5, D5, DS5, E5, F5, FS5, G5, GS5, A5, AS5, B5, C6, CS6, D6, DS6] # CHROMATIC
scale_6 = [C5, CS5, E5, F5, G5, GS5, B5, C6, CS6, E6, F6, G6, GS6, B6, C7, CS7]	  # ARABIC
scale_7 = [C5, CS5, D5, DS5, E5, F5, FS5, G5, GS5, A5, AS5, B5, C6, CS6, D6, DS6] # CUSTOM
scale_8 = [C5, CS5, D5, DS5, E5, F5, FS5, G5, GS5, A5, AS5, B5, C6, CS6, D6, DS6] # CUSTOM
# fmt: on

# THERE MUST BE EXACTLY 8 SCALES!
SCALES = [scale_1, scale_2, scale_3, scale_4, scale_5, scale_6, scale_7, scale_8]



class CC(IntEnum):
    """Maschine MK3 Control Change (CC) Numbers Enum"""

    # -------- CONTROL BUTTONS SECTION -------- #
    CHANNEL = 34
    PLUGIN = 35
    ARRANGER = 36
    MIXER = 37
    BROWSER = 38
    FILE_SAVE = 40
    SETTINGS = 41

    # -------- EDIT (ENCODER) SECTION -------- #
    ENCODER_PUSH = 7
    ENCODER_TURN = 8
    ENCODER_UP = 30
    ENCODER_RIGHT = 31
    ENCODER_DOWN = 32
    ENCODER_LEFT = 33

    ENCODER_VOLUME = 44
    ENCODER_SWING = 45
    ENCODER_TEMPO = 47

    # -------- TOUCH STRIP SECTION -------- #
    TOUCH_STRIP = 1

    TOUCH_STRIP_PITCH = 49
    TOUCH_STRIP_MOD = 50
    TOUCH_STRIP_PERFORM = 51
    TOUCH_STRIP_NOTES = 52

    # -------- GROUP SECTION -------- #
    GROUP_A = 100
    GROUP_B = 101
    GROUP_C = 102
    GROUP_D = 103
    GROUP_E = 104
    GROUP_F = 105
    GROUP_G = 106
    GROUP_H = 107

    # -------- TRANSPORT SECTION -------- #
    RESTART = 53
    ERASE = 54
    TAP = 55
    PLAY = 57
    GRID = 56
    REC = 58
    STOP = 59

    # -------- PAD SECTION -------- #
    FIXED_VEL = 81

    # PAD MODES
    PAD_MODE = 80
    KEYBOARD_MODE = 82
    CHORDS_MODE = 84
    STEP_MODE = 83

    PATTERN = 86
    SELECT = 90
    SOLO = 91
    MUTE = 92

    # ---- KNOB PAGE SECTION ---- #
    # BUTTONS
    PRESET_NEXT = 22
    PRESET_PREV = 23
    OCTAVE_DOWN = 26
    OCTAVE_UP = 27
    SEMI_DOWN = 28
    SEMI_UP = 29

    # KNOBS
    MIX_TRACK = 70
    MIX_VOL = 71
    MIX_PAN = 72
    MIX_SS = 73
    CHAN_SEL = 74
    CHAN_VOL = 75
    CHAN_PAN = 76
    FIX_VEL = 77

    # Original Shift button is reserved by Maschine
    # so we assign it to another CC that is not used (FOLLOW)
    SHIFT = 46



def _get_channel_color(
    channel: int,
    highlighted: bool,
) -> int:
    """
    Return the LED color for a channel or plugin pad.

    Args:
        channel: Channel index to test for plugin validity.
        highlighted: Whether the pad should use the highlighted color.

    Returns:
        MIDI color value for the pad LED.
    """
    color = PluginColor if plugins.isValid(channel) else ChannelColor
    return color.HIGHLIGHTED.value if highlighted else color.DEFAULT.value  # type: ignore[attr-defined]


def _midi_out_msg_note_on(
    note: int,
    velocity: int,
    channel: int = 0,
) -> None:
    """
    Send a MIDI NOTE ON (144) message to the device.

    This is a thin wrapper around `device.midiOutMsg` that sends a NOTE ON
    message on the specified MIDI channel. A velocity of 0 is treated by
    MIDI devices as NOTE OFF.

    Args:
        note (int): MIDI note number (0–127).
        velocity (int): Note velocity (0–127). A value of 0 acts as NOTE OFF.
        channel (int, optional): MIDI channel (0–15). Defaults to 0.

    Returns:
        None
    """
    device.midiOutMsg(
        midi.MIDI_NOTEON,
        channel,
        note,
        velocity,
    )


def _midi_out_msg_control_change(
    control: int,
    value: int,
    channel: int = 0,
) -> None:
    """
    Send a MIDI CONTROL CHANGE (CC) (176) message to the device.

    This is a thin wrapper around `device.midiOutMsg` that sends a Control
    Change message on the specified MIDI channel.

    Args:
        control (int): MIDI controller number (0–127).
        value (int): Controller value (0–127).
        channel (int, optional): MIDI channel (0–15). Defaults to 0.

    Returns:
        None
    """
    device.midiOutMsg(
        midi.MIDI_CONTROLCHANGE,
        channel,
        control,
        value,
    )


def _on_off(condition: bool) -> int:
    """Helper to convert boolean to MIDI on/off value
    Args:
        condition (bool): Condition to evaluate
    Returns:
        int: 127 if condition is True, else 0
    """
    return 127 if condition else 0


def _percent_to_bipolar(percent: int) -> float:
    """Convert a percent value (0-100) to a bipolar value (-1.0 to 1.0)"""
    return (percent / 50.0) - 1.0


def _bipolar_to_percent(bipolar: float) -> int:
    """Convert a bipolar value (-1.0 to 1.0) to a percent value (0-100)"""
    return round((bipolar + 1.0) * 50)


class Controller:
    """Represents the state of the Maschine MK3 controller"""

    _pad_mode: PadMode
    """Current pad mode. See PadMode Enum"""

    _pad_mode_color: PadModeColor
    """Current pad mode color. See PadModeColor Enum"""

    _encoder_mode: FourDEncoderMode
    """Current 4D encoder mode. See FourDEncoderMode Enum"""

    _touch_strip_mode: TouchStripMode
    """Current touch strip mode. See TouchStripMode Enum"""

    _active_group: PadGroup
    """Current selected group (A-H)"""

    _channel_page: int
    """Current channel page (0-15) for OMNI mode pad display"""

    _step_page: int
    """Current step sequence page (0-15) for STEP mode pad display"""

    _semi_offset: int
    """Current semitone offset"""

    _scale_index: int
    """Current scale index for keyboard mode (0-7)"""

    _chordset_index: int
    """Current chord set index for chords mode (0-7)"""

    _fixed_velocity: int
    """Fixed velocity value for pads when fixed velocity mode is enabled"""

    _is_fixed_velocity: bool
    """Indicates whether fixed velocity mode is enabled"""

    _shifting: bool
    """Indicates whether the shift button is currently pressed"""

    _is_plugin_picker_active: bool
    """Indicates whether the plugin picker is currently active"""

    _is_selecting_pattern: bool
    """Indicates whether the user is currently selecting a pattern"""

    _is_selecting_channel: bool
    """Indicates whether the user is currently selecting a channel"""

    def __init__(self):
        self._pad_mode = PadMode.OMNI
        self._pad_mode_color = PadModeColor.OMNI
        self._encoder_mode = FourDEncoderMode.JOG
        self._touch_strip_mode = TouchStripMode.TRANSPORT
        self._active_group = PadGroup.A
        self._channel_page = 0
        self._step_page = 0
        self._semi_offset = 0
        self._scale_index = 0
        self._chordset_index = 0
        self._fixed_velocity = 100
        self._is_fixed_velocity = False
        self._shifting = False
        self._is_plugin_picker_active = False
        self._is_selecting_pattern = False
        self._is_selecting_channel = False

    def on_init(self) -> None:
        self._init_led_states()
        self._sync_cc_led_states()
        self._sync_channel_rack_pads()
        self._sync_channel_rack_controls()
        self._sync_mixer_controls()
        self._sync_song_position()

    def on_de_init(self) -> None:
        self._deinit_led_states()

    def on_refresh(self, flags: int) -> None:
        # `flags` is a bitmask — a single integer where each bit represents a different type of state change,
        # allowing multiple updates to be signaled at once.

        channel_event = flags & midi.HW_ChannelEvent
        pattern_event = flags & midi.HW_Dirty_Patterns
        control_values_event = flags & midi.HW_Dirty_ControlValues
        mixer_sel_event = flags & midi.HW_Dirty_Mixer_Sel
        mixer_display_event = flags & midi.HW_Dirty_Mixer_Display
        mixer_controls_event = flags & midi.HW_Dirty_Mixer_Controls
        leds_event = flags & midi.HW_Dirty_LEDs

        # This `elif` block is needed because `leds_event` is triggered alongside other events
        # so we only want to run the full leds sync logic when no other events are present.
        # e.g. `leds_event` is triggered alongside `channel_event`, so we only want to sync leds
        # that are related to `channel_event` in that case.
        if channel_event and leds_event:
            if not self._is_plugin_picker_active:
                self._sync_channel_rack_controls()
            if not self._is_plugin_picker_active:
                self._sync_channel_rack_pads()
        elif mixer_sel_event or mixer_display_event or mixer_controls_event:
            if not self._is_plugin_picker_active:
                self._sync_mixer_controls()
        elif leds_event:
            self._sync_cc_led_states()
            if self._touch_strip_mode == TouchStripMode.TRANSPORT:
                self._sync_song_position()
            if not self._is_selecting_pattern:
                self._sync_channel_rack_pads()

        if pattern_event:
            if not self._is_selecting_pattern:
                self._sync_channel_rack_pads()

        if control_values_event:
            if self._touch_strip_mode == TouchStripMode.PITCH:
                self._sync_touch_strip_value(self._touch_strip_mode)
            if not self._is_plugin_picker_active:
                self._sync_channel_rack_controls()

        # # Debugging output for refresh flags
        # if flags & midi.HW_Dirty_Mixer_Sel:
        #     print("midi.HW_Dirty_Mixer_Sel")
        # if flags & midi.HW_Dirty_Mixer_Display:
        #     print("midi.HW_Dirty_Mixer_Display")
        # if flags & midi.HW_Dirty_Mixer_Controls:
        #     print("midi.HW_Dirty_Mixer_Controls")
        # if flags & midi.HW_Dirty_FocusedWindow:
        #     print("midi.HW_Dirty_FocusedWindow")
        # if flags & midi.HW_Dirty_Performance:
        #     print("midi.HW_Dirty_Performance")
        # if flags & midi.HW_Dirty_LEDs:
        #     print("midi.HW_Dirty_LEDs")
        # if flags & midi.HW_Dirty_Patterns:
        #     print("midi.HW_Dirty_Patterns")
        # if flags & midi.HW_Dirty_Tracks:
        #     print("midi.HW_Dirty_Tracks")
        # if flags & midi.HW_Dirty_ControlValues:
        #     print("midi.HW_Dirty_ControlValues")
        # if flags & midi.HW_Dirty_Colors:
        #     print("midi.HW_Dirty_Colors")
        # if flags & midi.HW_Dirty_Names:
        #     print("midi.HW_Dirty_Names")
        # if flags & midi.HW_Dirty_ChannelRackGroup:
        #     print("midi.HW_Dirty_ChannelRackGroup")
        # if flags & midi.HW_ChannelEvent:
        #     print("midi.HW_ChannelEvent")

    def on_control_change(self, msg) -> None:
        cc_num, cc_val = msg.controlNum, msg.controlVal

        match cc_num:
            # -------- CONTROL BUTTONS SECTION -------- #
            case CC.CHANNEL:
                if ui.getVisible(midi.widChannelRack):
                    ui.hideWindow(midi.widChannelRack)
                else:
                    ui.showWindow(midi.widChannelRack)

            case CC.PLUGIN:
                channels.showCSForm(channels.selectedChannel(), -1)

            case CC.ARRANGER:
                if ui.getVisible(midi.widPlaylist):
                    ui.hideWindow(midi.widPlaylist)
                else:
                    ui.showWindow(midi.widPlaylist)

            case CC.MIXER:
                if ui.getVisible(midi.widMixer):
                    ui.hideWindow(midi.widMixer)
                else:
                    ui.showWindow(midi.widMixer)

            case CC.BROWSER if self._shifting:  # PLUGIN PICKER
                self._is_plugin_picker_active = not self._is_plugin_picker_active
                transport.globalTransport(midi.FPT_F8, 1)
            case CC.BROWSER:
                if ui.getVisible(midi.widBrowser):
                    ui.hideWindow(midi.widBrowser)
                else:
                    ui.showWindow(midi.widBrowser)

            case CC.FILE_SAVE:
                transport.globalTransport(midi.FPT_Save, 1)

            case CC.SETTINGS:
                transport.globalTransport(midi.FPT_F10, 1)

            # -------- EDIT (ENCODER) SECTION -------- #
            case CC.ENCODER_PUSH:
                ui.enter()

            case CC.ENCODER_TURN:
                is_clockwise = cc_val == 65  # CLOCKWISE
                multiplier = 1 if is_clockwise else -1

                track_number = mixer.trackNumber()
                selected_channel = channels.selectedChannel()

                match self._encoder_mode:
                    case FourDEncoderMode.JOG:
                        ui.jog(1 * multiplier)

                    case FourDEncoderMode.VOLUME:
                        if ui.getFocused(midi.widMixer):
                            target_vol = (
                                mixer.getTrackVolume(track_number)
                                + MIXER_TRACK_VOL_STEP * multiplier
                            )
                            if 0.0 < target_vol < 1.0:
                                mixer.setTrackVolume(track_number, target_vol)
                        elif ui.getFocused(midi.widChannelRack):
                            channels.setChannelVolume(
                                selected_channel,
                                channels.getChannelVolume(selected_channel)
                                + CHANNEL_VOL_STEP * multiplier,
                            )

                    case FourDEncoderMode.SWING:
                        pass  # TODO implement swing adjustment

                    case FourDEncoderMode.TEMPO:
                        transport.globalTransport(midi.FPT_TempoJog, 10 * multiplier)

            case CC.ENCODER_UP:
                ui.up()

            case CC.ENCODER_RIGHT:
                ui.right()

            case CC.ENCODER_DOWN:
                ui.down()

            case CC.ENCODER_LEFT:
                ui.left()

            case CC.ENCODER_VOLUME | CC.ENCODER_SWING | CC.ENCODER_TEMPO:
                self._toggle_encoder_mode(cc_num)

            # -------- TOUCH STRIP SECTION -------- #
            case CC.TOUCH_STRIP:
                match self._touch_strip_mode:
                    case TouchStripMode.TRANSPORT:
                        transport.setSongPos(cc_val / 100)
                        _midi_out_msg_control_change(CC.TOUCH_STRIP, cc_val)
                    case TouchStripMode.PITCH:
                        channels.setChannelPitch(
                            channels.selectedChannel(),
                            _percent_to_bipolar(cc_val),
                        )
                    case TouchStripMode.MOD:
                        pass  # TODO
                    case TouchStripMode.PERFORM:
                        pass  # TODO
                    case TouchStripMode.NOTES:
                        pass  # TODO

            case (
                CC.TOUCH_STRIP_PITCH
                | CC.TOUCH_STRIP_MOD
                | CC.TOUCH_STRIP_PERFORM
                | CC.TOUCH_STRIP_NOTES
            ):
                self._toggle_touch_strip_mode(cc_num)
                self._sync_touch_strip_value(self._touch_strip_mode)

            # -------- GROUP SECTION -------- #

            case (
                CC.GROUP_A
                | CC.GROUP_B
                | CC.GROUP_C
                | CC.GROUP_D
                | CC.GROUP_E
                | CC.GROUP_F
                | CC.GROUP_G
                | CC.GROUP_H
            ):
                page_idx = cc_num - 100

                match self._pad_mode:
                    case PadMode.OMNI:
                        self._channel_page = page_idx
                    case PadMode.KEYBOARD:
                        self._scale_index = page_idx
                    case PadMode.CHORDS:
                        self._chordset_index = page_idx
                    case PadMode.STEP:
                        self._step_page = page_idx
                    case _:
                        return

                self._active_group = PadGroup(cc_num)
                self._change_group_colors()

                self._sync_channel_rack_pads()

            # -------- TRASPORT SECTION -------- #
            case CC.RESTART if self._shifting:  # LOOP
                transport.setLoopMode()
            case CC.RESTART:
                transport.stop()
                transport.start()

            case CC.ERASE:
                ui.delete()

            case CC.TAP if self._shifting:  # METRO
                transport.globalTransport(midi.FPT_Metronome, 1)
            case CC.TAP:
                if cc_val:
                    transport.globalTransport(midi.FPT_TapTempo, 1)

            case CC.GRID:
                ui.snapOnOff()

            case CC.PLAY:
                transport.start()

            case CC.STOP:
                transport.stop()

            case CC.REC if self._shifting:  # Count-in
                transport.globalTransport(midi.FPT_CountDown, 1)
            case CC.REC:
                transport.record()

            # -------- PAD SECTION -------- #
            case CC.FIXED_VEL:
                self._is_fixed_velocity = bool(cc_val)

            case CC.PAD_MODE | CC.KEYBOARD_MODE | CC.CHORDS_MODE | CC.STEP_MODE:
                for cc in (CC.PAD_MODE, CC.KEYBOARD_MODE, CC.CHORDS_MODE, CC.STEP_MODE):
                    _midi_out_msg_control_change(cc, 127 if cc == cc_num else 0)

                active_group = PadGroup.A
                match cc_num:
                    case CC.PAD_MODE:
                        self._pad_mode = PadMode.OMNI
                        self._pad_mode_color = PadModeColor.OMNI
                        active_group += self._channel_page

                    case CC.KEYBOARD_MODE:
                        self._pad_mode = PadMode.KEYBOARD
                        self._pad_mode_color = PadModeColor.KEYBOARD
                        active_group += self._scale_index

                    case CC.CHORDS_MODE:
                        self._pad_mode = PadMode.CHORDS
                        self._pad_mode_color = PadModeColor.CHORDS
                        active_group += self._chordset_index

                    case CC.STEP_MODE:
                        self._pad_mode = PadMode.STEP
                        self._pad_mode_color = PadModeColor.STEP
                        active_group += self._step_page

                    case _:
                        pass

                self._active_group = PadGroup(active_group)
                self._change_group_colors()

                self._sync_channel_rack_pads()

            case CC.PATTERN:
                for p in range(16):
                    _midi_out_msg_note_on(p, ControllerColor.BLACK_0)

                self._is_selecting_pattern = bool(cc_val)

                if cc_val:
                    self._sync_patterns()
                else:
                    if self._pad_mode in (PadMode.OMNI, PadMode.STEP):
                        self._sync_channel_rack_pads()

            case CC.SELECT:
                self._is_selecting_channel = bool(cc_val)

            case CC.SOLO:
                if ui.getFocused(midi.widChannelRack):
                    channels.soloChannel(channels.selectedChannel())
                elif ui.getFocused(midi.widMixer):
                    if self._shifting:
                        mixer.soloTrack(
                            mixer.trackNumber(), -1, midi.fxSoloModeWithSourceTracks
                        )
                    else:
                        mixer.soloTrack(
                            mixer.trackNumber(), -1, midi.fxSoloModeWithDestTracks
                        )

            case CC.MUTE:
                if ui.getFocused(midi.widChannelRack):
                    channels.muteChannel(channels.selectedChannel())
                elif ui.getFocused(midi.widMixer):
                    mixer.muteTrack(mixer.trackNumber())

            # ---- KNOB PAGE SECTION ---- #
            # BUTTONS
            case CC.PRESET_NEXT | CC.PRESET_PREV:  # TODO: add mixer logic
                selected_channel = channels.selectedChannel()

                if not plugins.isValid(selected_channel):
                    return

                if cc_num == CC.PRESET_NEXT:
                    plugins.nextPreset(selected_channel)
                else:
                    plugins.prevPreset(selected_channel)

            case CC.OCTAVE_DOWN if self._semi_offset > MIN_SEMI_OFFSET:
                self._semi_offset -= 12

            case CC.OCTAVE_UP if self._semi_offset < MAX_SEMI_OFFSET:
                self._semi_offset += 12

            case CC.SEMI_DOWN if self._semi_offset > MIN_SEMI_OFFSET:
                self._semi_offset -= 1

            case CC.SEMI_UP if self._semi_offset < MAX_SEMI_OFFSET:
                self._semi_offset += 1

            # KNOBS
            case CC.MIX_TRACK:
                mixer.setTrackNumber(cc_val)

            case CC.MIX_VOL:
                mixer.setTrackVolume(mixer.trackNumber(), cc_val / 125)

            case CC.MIX_PAN:
                mixer.setTrackPan(mixer.trackNumber(), _percent_to_bipolar(cc_val))

            case CC.MIX_SS:
                mixer.setTrackStereoSep(
                    mixer.trackNumber(), _percent_to_bipolar(cc_val)
                )

            case CC.CHAN_SEL:
                if cc_val < channels.channelCount():
                    channels.selectOneChannel(cc_val)
                else:
                    _midi_out_msg_control_change(
                        CC.CHAN_SEL, channels.selectedChannel()
                    )

            case CC.CHAN_VOL:
                channels.setChannelVolume(channels.selectedChannel(), cc_val / 100)

            case CC.CHAN_PAN:
                channels.setChannelPan(
                    channels.selectedChannel(), _percent_to_bipolar(cc_val)
                )

            case CC.FIX_VEL:
                self._fixed_velocity = cc_val

            # -------- SHIFT -------- #
            case CC.SHIFT:
                self._shifting = bool(cc_val)

            # -------- DEFAULT -------- #
            case _:
                return

        msg.handled = True

    def on_note_on(self, msg) -> None:
        note_num, note_vel = msg.note, msg.velocity
        # velocity == 0 means note off

        if note_vel:
            if self._shifting:
                if note_num == 0:
                    general.undoUp()
                elif note_num == 1:
                    general.undoDown()
                msg.handled = True
            if self._is_selecting_pattern:
                patterns.jumpToPattern(note_num + 1)
                self._sync_patterns()
                msg.handled = True
            if self._is_selecting_channel:
                chan_idx = note_num + self._channel_page * 16
                if chan_idx < channels.channelCount():
                    channels.selectOneChannel(chan_idx)
                msg.handled = True

        if msg.handled:
            return

        match self._pad_mode:
            case PadMode.OMNI:
                real_note = ROOT_NOTE + self._get_semi_offset()
                chan_idx = note_num + self._channel_page * 16
                if chan_idx >= channels.channelCount():
                    return
                if note_vel:
                    channels.midiNoteOn(
                        chan_idx,
                        real_note,
                        self._fixed_velocity if self._is_fixed_velocity else note_vel,
                    )
                else:
                    channels.midiNoteOn(chan_idx, real_note, 0)

            case PadMode.KEYBOARD:
                real_note = (
                    SCALES[self._scale_index][note_num] + self._get_semi_offset()
                )
                if note_vel:
                    channels.midiNoteOn(
                        channels.selectedChannel(),
                        real_note,
                        self._fixed_velocity if self._is_fixed_velocity else note_vel,
                    )
                    _midi_out_msg_note_on(note_num, PadModeColor.KEYBOARD)
                else:
                    channels.midiNoteOn(channels.selectedChannel(), real_note, 0)
                    _midi_out_msg_note_on(note_num, ControllerColor.BLACK_0)

            case PadMode.CHORDS:
                chord_notes = CHORD_SETS[self._chordset_index][note_num]
                for note in chord_notes:
                    real_note = note + self._get_semi_offset()
                    if note_vel:
                        channels.midiNoteOn(
                            channels.selectedChannel(),
                            real_note,
                            (
                                self._fixed_velocity
                                if self._is_fixed_velocity
                                else note_vel
                            ),
                        )
                        _midi_out_msg_note_on(note_num, PadModeColor.CHORDS)
                    else:
                        channels.midiNoteOn(channels.selectedChannel(), real_note, 0)
                        _midi_out_msg_note_on(note_num, ControllerColor.BLACK_0)

            case PadMode.STEP if note_vel:
                chan_idx = note_num + self._step_page * 16
                selected_channel = channels.selectedChannel()
                channels.setGridBit(
                    selected_channel,
                    chan_idx,
                    not channels.getGridBit(selected_channel, chan_idx),
                )

            case _:
                return

        msg.handled = True

    def _init_led_states(self) -> None:
        self._deinit_led_states()

        # fmt: off
        _midi_out_msg_control_change(CC.GROUP_A, self._pad_mode_color)
        _midi_out_msg_control_change(CC.PAD_MODE, 127)
        _midi_out_msg_control_change(CC.FIX_VEL, 100)
        # fmt: on

    @staticmethod
    def _deinit_led_states() -> None:
        """De-initializes the LED states on the Maschine MK3 device"""

        for cc in range(CC_RANGE):
            _midi_out_msg_control_change(cc, ControllerColor.BLACK_0)

        for note in range(NOTES_RANGE):
            _midi_out_msg_note_on(note, ControllerColor.BLACK_0)

    def _sync_cc_led_states(self) -> None:
        """Syncs the CC LED states with the current FL Studio state"""

        # fmt: off
        _midi_out_msg_control_change(CC.CHANNEL,  _on_off(ui.getVisible(midi.widChannelRack)))
        _midi_out_msg_control_change(CC.ARRANGER, _on_off(ui.getVisible(midi.widPlaylist)))
        _midi_out_msg_control_change(CC.MIXER,    _on_off(ui.getVisible(midi.widMixer)))
        _midi_out_msg_control_change(CC.RESTART,  _on_off(bool(transport.getLoopMode())))
        _midi_out_msg_control_change(CC.BROWSER,  _on_off(ui.getVisible(midi.widBrowser)))
        _midi_out_msg_control_change(CC.TAP,      _on_off(general.getUseMetronome()))
        _midi_out_msg_control_change(CC.PLAY,     _on_off(transport.isPlaying()))
        _midi_out_msg_control_change(CC.REC,      _on_off(transport.isRecording()))
        _midi_out_msg_control_change(CC.STOP,     _on_off(not transport.isPlaying()))
        _midi_out_msg_control_change(CC.GRID,     _on_off(ui.getSnapMode() != 3))
        # fmt: on

    def _sync_channel_rack_pads(self) -> None:
        """Syncs the channel rack state with the pad LEDs on the Maschine MK3 device"""

        for note in range(NOTES_RANGE):
            _midi_out_msg_note_on(note, ControllerColor.BLACK_0)

        selected_channel = channels.selectedChannel()

        if self._pad_mode == PadMode.OMNI:
            lower_channel = self._channel_page * 16
            channel_count = channels.channelCount()

            # turn on pads for available channels
            for channel in range(lower_channel, channel_count):
                idx = channel - lower_channel
                if idx == 16:
                    break
                _midi_out_msg_note_on(idx, _get_channel_color(channel, False))

            # highlight selected channel pad
            if selected_channel in range(lower_channel, channel_count):
                channel = selected_channel - lower_channel
                _midi_out_msg_note_on(channel, _get_channel_color(channel, True))

        elif self._pad_mode == PadMode.STEP:
            lower_step = self._step_page * 16

            # turn on pads for step sequencer grid bits
            for gridbit in range(lower_step, lower_step + 16):
                idx = gridbit - lower_step
                _midi_out_msg_note_on(
                    idx,
                    (
                        PadModeColor.STEP
                        if channels.getGridBit(selected_channel, gridbit)
                        else ControllerColor.BLACK_0
                    ),
                )

    @staticmethod
    def _sync_channel_rack_controls() -> None:
        """Syncs the channel rack controls on the Maschine MK3 device with the current FL Studio channel rack state"""

        selected_channel = channels.selectedChannel()

        # fmt: off
        _midi_out_msg_control_change(CC.CHAN_SEL, selected_channel)
        _midi_out_msg_control_change(CC.CHAN_VOL, round(channels.getChannelVolume(selected_channel) * 100))
        _midi_out_msg_control_change(CC.CHAN_PAN, _bipolar_to_percent(channels.getChannelPan(selected_channel)))
        _midi_out_msg_control_change(CC.SOLO, _on_off(channels.isChannelSolo(selected_channel)))
        _midi_out_msg_control_change(CC.MUTE, _on_off(channels.isChannelMuted(selected_channel)))        
        # fmt: on

    @staticmethod
    def _sync_mixer_controls() -> None:
        """Syncs the mixer (encoders) values on the Maschine MK3 device with the current FL Studio mixer state"""

        track_number = mixer.trackNumber()

        # fmt: off
        _midi_out_msg_control_change(CC.MIX_TRACK, track_number)
        _midi_out_msg_control_change(CC.MIX_VOL, round(mixer.getTrackVolume(track_number) * 125))
        _midi_out_msg_control_change(CC.MIX_PAN, _bipolar_to_percent(mixer.getTrackPan(track_number)))
        _midi_out_msg_control_change(CC.MIX_SS, _bipolar_to_percent(mixer.getTrackStereoSep(track_number)))
        _midi_out_msg_control_change(CC.SOLO, _on_off(mixer.isTrackSolo(track_number)))
        _midi_out_msg_control_change(CC.MUTE, _on_off(mixer.isTrackMuted(track_number)))
        # fmt: on

    def _toggle_encoder_mode(self, cc: int) -> None:
        """Toggles the 4D encoder mode based on the given control change number"""

        match cc:
            case CC.ENCODER_VOLUME:
                mode = FourDEncoderMode.VOLUME
            case CC.ENCODER_SWING:
                mode = FourDEncoderMode.SWING
            case CC.ENCODER_TEMPO:
                mode = FourDEncoderMode.TEMPO
            case _:
                mode = FourDEncoderMode.JOG

        mode = mode if self._encoder_mode != mode else FourDEncoderMode.JOG

        for cc_num in (CC.ENCODER_VOLUME, CC.ENCODER_SWING, CC.ENCODER_TEMPO):
            _midi_out_msg_control_change(
                cc_num,
                (127 if cc == cc_num and mode != FourDEncoderMode.JOG else 0),
            )

        self._encoder_mode = mode

    def _toggle_touch_strip_mode(self, cc: int) -> None:
        """Toggles the touch strip mode based on the given control change number"""

        match cc:
            case CC.TOUCH_STRIP_PITCH:
                mode = TouchStripMode.PITCH
            case CC.TOUCH_STRIP_MOD:
                mode = TouchStripMode.MOD
            case CC.TOUCH_STRIP_PERFORM:
                mode = TouchStripMode.PERFORM
            case CC.TOUCH_STRIP_NOTES:
                mode = TouchStripMode.NOTES
            case _:
                mode = TouchStripMode.TRANSPORT

        mode = mode if self._touch_strip_mode != mode else TouchStripMode.TRANSPORT

        for cc_num in (
            CC.TOUCH_STRIP_PITCH,
            CC.TOUCH_STRIP_MOD,
            CC.TOUCH_STRIP_PERFORM,
            CC.TOUCH_STRIP_NOTES,
        ):
            _midi_out_msg_control_change(
                cc_num,
                (127 if cc == cc_num and mode != TouchStripMode.TRANSPORT else 0),
            )

        self._touch_strip_mode = mode

    def _sync_touch_strip_value(self, mode: TouchStripMode) -> None:
        """Syncs the touch strip value on the Maschine MK3 device with the current FL Studio state based on the given mode"""

        match mode:
            case TouchStripMode.TRANSPORT:
                self._sync_song_position()
            case TouchStripMode.PITCH:
                _midi_out_msg_control_change(
                    CC.TOUCH_STRIP,
                    _bipolar_to_percent(
                        channels.getChannelPitch(channels.selectedChannel())
                    ),
                )
            case TouchStripMode.MOD:
                pass  # TODO
            case TouchStripMode.PERFORM:
                pass  # TODO
            case TouchStripMode.NOTES:
                pass  # TODO

    def _sync_song_position(self) -> None:
        """Syncs the touch strip song position value on the Maschine MK3 device"""

        _midi_out_msg_control_change(CC.TOUCH_STRIP, int(transport.getSongPos() * 100))

    def _change_group_colors(self) -> None:
        """Updates the group button colors based on the current pad mode"""

        for cc in range(CC.GROUP_A, CC.GROUP_H + 1):
            _midi_out_msg_control_change(
                cc,
                (
                    self._pad_mode_color
                    if cc == self._active_group
                    else ControllerColor.BLACK_0
                ),
            )

    def _sync_patterns(self) -> None:
        """Syncs the pattern selection state on the Maschine MK3 device with the current FL Studio state"""

        for pattern in range(patterns.patternCount()):
            _midi_out_msg_note_on(
                pattern,
                (
                    ControllerColor.ORANGE_2
                    if patterns.isPatternSelected(pattern + 1)
                    else ControllerColor.ORANGE_1
                ),
            )

    def _get_semi_offset(self) -> int:
        """Returns the current semitone offset"""
        return self._semi_offset + SEMITONES_IN_OCTAVE



controller = Controller()


def OnInit() -> None:
    """
    Called when FL Studio initializes the script.

    Note that the script may be kept in memory after being de-initialized with OnDeInit(),
    so this function may be called more than once during the lifetime of this Python script.
    """
    controller.on_init()


def OnDeInit() -> None:
    """
    Called before FL Studio de-initializes the script.

    This function should be used to shut down the attached device
    """
    controller.on_de_init()


def OnRefresh(flags: int) -> None:
    """
    Called when certain events occur within FL Studio.
    Scripts should use the provided flags to update required interfaces on their associated controllers.

    flags values will be a bitwise combination of the OnRefresh flags.

    Args:
        flags (int): flags to represent the changes in FL Studio's state.
    """
    controller.on_refresh(flags)


def OnControlChange(msg) -> None:
    """
    Called after callbacks.OnMidiMsg() for control change (CC) MIDI events.

    Args:
        msg (fl_classes.FlMidiMsg): incoming control change MIDI message.
    """
    controller.on_control_change(msg)


def OnNoteOn(msg) -> None:
    """
    Called after callbacks.OnMidiMsg() for note on MIDI events.

    Args:
        msg (fl_classes.FlMidiMsg): incoming note on MIDI message.
    """
    controller.on_note_on(msg)
